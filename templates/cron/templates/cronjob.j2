# ========== cronjob.j2 ==========
# Cron job: {{ job_name }}
# Generated by OpsArtisan
# Schedule: {{ schedule }}
{% if error_notification %}
MAILTO={{ notification_email }}
{% else %}
MAILTO=""
{% endif %}

{% if logging_enabled %}
# With logging to {{ log_path }}
{{ schedule }} {{ command }} >> {{ log_path }} 2>&1
{% else %}
{{ schedule }} {{ command }}
{% endif %}

# To install this cron job:
# crontab -e
# Then paste the line above

# ========== systemd_service.j2 ==========
[Unit]
Description={{ job_name }} scheduled job
Documentation=man:cron(8)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
User={{ user }}
Group={{ user }}
WorkingDirectory={{ working_directory }}
{% if logging_enabled %}
StandardOutput=append:{{ log_path }}
StandardError=append:{{ log_path }}
{% else %}
StandardOutput=journal
StandardError=journal
{% endif %}
ExecStart={{ command }}
{% if timeout %}
TimeoutStartSec={{ timeout }}
{% endif %}
{% if retry_on_failure %}
Restart=on-failure
RestartSec=300
StartLimitBurst={{ max_retries }}
StartLimitIntervalSec=3600
{% endif %}

# Security settings
PrivateTmp=yes
NoNewPrivileges=yes
{% if user != 'root' %}
ProtectSystem=strict
ProtectHome=yes
ReadWritePaths={{ working_directory }}
{% if logging_enabled %}
ReadWritePaths={{ log_path | dirname }}
{% endif %}
{% endif %}

[Install]
WantedBy=multi-user.target

# ========== systemd_timer.j2 ==========
[Unit]
Description=Timer for {{ job_name }}
Requires={{ job_name }}.service

[Timer]
OnCalendar={{ systemd_schedule }}
Persistent=true
AccuracySec=1min

[Install]
WantedBy=timers.target

# ========== k8s_cronjob.j2 ==========
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ job_name }}
  namespace: {{ k8s_namespace }}
  labels:
    app: {{ job_name }}
    managed-by: opsartisan
spec:
  schedule: "{{ schedule }}"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  suspend: false
  jobTemplate:
    metadata:
      labels:
        app: {{ job_name }}
        job-name: {{ job_name }}
    spec:
      {% if retry_on_failure %}
      backoffLimit: {{ max_retries }}
      {% else %}
      backoffLimit: 0
      {% endif %}
      activeDeadlineSeconds: {{ timeout }}
      template:
        metadata:
          labels:
            app: {{ job_name }}
        spec:
          restartPolicy: OnFailure
          containers:
            - name: {{ job_name }}
              image: {{ k8s_image }}
              imagePullPolicy: IfNotPresent
              command:
                - /bin/sh
                - -c
                - {{ command }}
              workingDir: {{ working_directory }}
              env:
                - name: JOB_NAME
                  value: "{{ job_name }}"
                - name: NAMESPACE
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.namespace
              resources:
                requests:
                  cpu: 100m
                  memory: 128Mi
                limits:
                  cpu: 500m
                  memory: 512Mi
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            fsGroup: 1000

# ========== job_script.j2 ==========
#!/usr/bin/env bash
#
# {{ job_name }} - Job script
# Generated by OpsArtisan
#
{% if schedule_type == 'cron' %}
# Cron schedule: {{ schedule }}
{% elif schedule_type == 'systemd' %}
# systemd schedule: {{ systemd_schedule }}
{% elif schedule_type == 'kubernetes' %}
# Kubernetes schedule: {{ schedule }}
{% endif %}

set -euo pipefail

# Configuration
JOB_NAME="{{ job_name }}"
{% if logging_enabled and schedule_type != 'kubernetes' %}
LOG_FILE="{{ log_path }}"
{% endif %}
{% if working_directory %}
WORK_DIR="{{ working_directory }}"
{% endif %}

# Logging function
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] [${level}] ${message}"
{% if logging_enabled and schedule_type != 'kubernetes' %}
    echo "[${timestamp}] [${level}] ${message}" >> "${LOG_FILE}"
{% endif %}
}

# Error handler
error_exit() {
    log "ERROR" "$1"
{% if error_notification and schedule_type == 'cron' %}
    echo "$1" | mail -s "Job Failed: ${JOB_NAME}" {{ notification_email }}
{% endif %}
    exit 1
}

# Trap errors
trap 'error_exit "Job failed on line $LINENO"' ERR

# Main job logic
main() {
    log "INFO" "Starting job: ${JOB_NAME}"

{% if working_directory %}
    # Change to working directory
    cd "${WORK_DIR}" || error_exit "Failed to change to working directory"
    log "INFO" "Working directory: $(pwd)"
{% endif %}

    # ============================================
    # YOUR JOB LOGIC HERE
    # ============================================

    # Example: Run your command
    log "INFO" "Executing: {{ command }}"
    {{ command }}

    # ============================================

    log "INFO" "Job completed successfully"
}

# Run main function
main "$@"

# ========== wrapper_script.j2 ==========
#!/usr/bin/env bash
#
# {{ job_name }} wrapper script
# Provides error handling, locking, and monitoring
#

set -euo pipefail

# Configuration
JOB_NAME="{{ job_name }}"
LOCK_FILE="/var/run/${JOB_NAME}.lock"
{% if logging_enabled %}
LOG_FILE="{{ log_path }}"
{% endif %}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
JOB_SCRIPT="${SCRIPT_DIR}/{{ job_name }}.sh"
{% if timeout %}
TIMEOUT={{ timeout }}
{% endif %}

# Ensure log directory exists
{% if logging_enabled %}
mkdir -p "$(dirname "${LOG_FILE}")"
{% endif %}

# Logging
log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] $*"
{% if logging_enabled %}
    echo "[${timestamp}] $*" >> "${LOG_FILE}"
{% endif %}
}

# Lock handling (prevent concurrent runs)
acquire_lock() {
    if [ -f "${LOCK_FILE}" ]; then
        local pid=$(cat "${LOCK_FILE}")
        if kill -0 "${pid}" 2>/dev/null; then
            log "ERROR: Job already running (PID: ${pid})"
            exit 1
        else
            log "WARN: Stale lock file found, removing"
            rm -f "${LOCK_FILE}"
        fi
    fi
    echo $$ > "${LOCK_FILE}"
}

release_lock() {
    rm -f "${LOCK_FILE}"
}

# Cleanup on exit
cleanup() {
    local exit_code=$?
    release_lock
    if [ ${exit_code} -eq 0 ]; then
        log "INFO: Job completed successfully"
    else
        log "ERROR: Job failed with exit code ${exit_code}"
{% if error_notification and schedule_type == 'cron' %}
        echo "Job ${JOB_NAME} failed with exit code ${exit_code}" | \
            mail -s "Job Failed: ${JOB_NAME}" {{ notification_email }}
{% endif %}
    fi
    exit ${exit_code}
}

trap cleanup EXIT INT TERM

# Main execution
main() {
    log "INFO: Starting job wrapper for ${JOB_NAME}"

    acquire_lock

    local start_time=$(date +%s)

    # Run the job with timeout if specified
{% if timeout %}
    if timeout ${TIMEOUT} bash "${JOB_SCRIPT}"; then
        local status=0
    else
        local status=$?
        if [ ${status} -eq 124 ]; then
            log "ERROR: Job timed out after ${TIMEOUT} seconds"
        fi
    fi
{% else %}
    bash "${JOB_SCRIPT}"
    local status=$?
{% endif %}

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    log "INFO: Job duration: ${duration} seconds"

    return ${status}
}

main "$@"

# ========== readme.j2 ==========
# {{ job_name }} - Scheduled Job

{% if schedule_type == 'cron' %}
Cron job scheduled to run: `{{ schedule }}`
{% elif schedule_type == 'systemd' %}
systemd timer scheduled to run: `{{ systemd_schedule }}`
{% elif schedule_type == 'kubernetes' %}
Kubernetes CronJob scheduled to run: `{{ schedule }}`
{% endif %}

## Overview

- **Job Name:** {{ job_name }}
- **Command:** `{{ command }}`
{% if working_directory %}
- **Working Directory:** {{ working_directory }}
{% endif %}
{% if logging_enabled and schedule_type != 'kubernetes' %}
- **Log File:** {{ log_path }}
{% endif %}
{% if timeout %}
- **Timeout:** {{ timeout }} seconds
{% endif %}
{% if retry_on_failure %}
- **Max Retries:** {{ max_retries }}
{% endif %}

## Files Generated

{% if schedule_type == 'cron' %}
- `{{ job_name }}.cron` - Cron entry
- `scripts/{{ job_name }}.sh` - Main job script
- `scripts/{{ job_name }}_wrapper.sh` - Wrapper with locking and error handling
{% elif schedule_type == 'systemd' %}
- `{{ job_name }}.service` - systemd service unit
- `{{ job_name }}.timer` - systemd timer unit
- `scripts/{{ job_name }}.sh` - Main job script
- `scripts/{{ job_name }}_wrapper.sh` - Wrapper script
{% elif schedule_type == 'kubernetes' %}
- `k8s/cronjob.yaml` - Kubernetes CronJob manifest
- `scripts/{{ job_name }}.sh` - Job script (for reference)
{% endif %}

## Installation

{% if schedule_type == 'cron' %}
### Cron Installation

1. **Test the script manually:**
   ```bash
   bash scripts/{{ job_name }}.sh
   ```

2. **Install to crontab:**
   ```bash
   crontab -e
   ```

3. **Add the line from {{ job_name }}.cron**

4. **Verify installation:**
   ```bash
   crontab -l | grep {{ job_name }}
   ```

5. **Monitor logs:**
   ```bash
{% if logging_enabled %}
   tail -f {{ log_path }}
{% else %}
   # Check system mail or add logging
{% endif %}
   ```

### Using the Wrapper Script (Recommended)

For better error handling and locking:

```bash
# Update your cron entry to use the wrapper
{{ schedule }} {{ command | replace(job_name + '.sh', job_name + '_wrapper.sh') }}
```

{% elif schedule_type == 'systemd' %}
### systemd Installation

1. **Test the script manually:**
   ```bash
   bash scripts/{{ job_name }}.sh
   ```

2. **Copy files to systemd:**
   ```bash
   sudo cp {{ job_name }}.service {{ job_name }}.timer /etc/systemd/system/
   ```

3. **Reload systemd:**
   ```bash
   sudo systemctl daemon-reload
   ```

4. **Enable and start the timer:**
   ```bash
   sudo systemctl enable --now {{ job_name }}.timer
   ```

5. **Check timer status:**
   ```bash
   sudo systemctl status {{ job_name }}.timer
   ```

6. **List all timers:**
   ```bash
   systemctl list-timers
   ```

7. **View logs:**
   ```bash
   # Real-time logs
   sudo journalctl -u {{ job_name }}.service -f

   # Last 50 lines
   sudo journalctl -u {{ job_name }}.service -n 50
{% if logging_enabled %}

   # Or check log file
   tail -f {{ log_path }}
{% endif %}
   ```

### Management Commands

```bash
# Start job manually
sudo systemctl start {{ job_name }}.service

# Stop the timer
sudo systemctl stop {{ job_name }}.timer

# Disable the timer
sudo systemctl disable {{ job_name }}.timer

# Check next run time
systemctl list-timers | grep {{ job_name }}
```

{% elif schedule_type == 'kubernetes' %}
### Kubernetes Installation

1. **Create namespace (if needed):**
   ```bash
   kubectl create namespace {{ k8s_namespace }}
   ```

2. **Apply the CronJob:**
   ```bash
   kubectl apply -f k8s/cronjob.yaml
   ```

3. **Verify CronJob:**
   ```bash
   kubectl get cronjobs -n {{ k8s_namespace }}
   ```

4. **View jobs created by CronJob:**
   ```bash
   kubectl get jobs -n {{ k8s_namespace }}
   ```

5. **View pods:**
   ```bash
   kubectl get pods -n {{ k8s_namespace }} -l job-name={{ job_name }}
   ```

6. **View logs:**
   ```bash
   # Latest job logs
   kubectl logs -l job-name={{ job_name }} -n {{ k8s_namespace }} --tail=100

   # Follow logs
   kubectl logs -l job-name={{ job_name }} -n {{ k8s_namespace }} -f
   ```

### Management Commands

```bash
# Trigger job manually
kubectl create job {{ job_name }}-manual --from=cronjob/{{ job_name }} -n {{ k8s_namespace }}

# Suspend CronJob
kubectl patch cronjob {{ job_name }} -n {{ k8s_namespace }} -p '{"spec":{"suspend":true}}'

# Resume CronJob
kubectl patch cronjob {{ job_name }} -n {{ k8s_namespace }} -p '{"spec":{"suspend":false}}'

# Delete CronJob
kubectl delete cronjob {{ job_name }} -n {{ k8s_namespace }}

# View CronJob history
kubectl get jobs -n {{ k8s_namespace }} -l app={{ job_name }}
```
{% endif %}

## Testing

Run the job manually to test:

```bash
bash scripts/{{ job_name }}.sh
```

{% if schedule_type in ['cron', 'systemd'] %}
Test with wrapper for full functionality:

```bash
bash scripts/{{ job_name }}_wrapper.sh
```
{% endif %}

## Troubleshooting

{% if schedule_type == 'cron' %}
### Cron Not Running

1. Check cron service:
   ```bash
   systemctl status cron  # or crond on some systems
   ```

2. Check logs:
   ```bash
   grep CRON /var/log/syslog
{% if logging_enabled %}
   tail -f {{ log_path }}
{% endif %}
   ```

3. Verify crontab:
   ```bash
   crontab -l
   ```

4. Check script permissions:
   ```bash
   ls -la scripts/{{ job_name }}.sh
   ```

{% elif schedule_type == 'systemd' %}
### Timer Not Running

1. Check timer is active:
   ```bash
   systemctl is-active {{ job_name }}.timer
   ```

2. Check timer status:
   ```bash
   systemctl status {{ job_name }}.timer
   ```

3. View detailed logs:
   ```bash
   journalctl -xe -u {{ job_name }}.service
   ```

4. Verify schedule:
   ```bash
   systemctl list-timers {{ job_name }}.timer
   ```

{% elif schedule_type == 'kubernetes' %}
### CronJob Not Running

1. Check CronJob status:
   ```bash
   kubectl describe cronjob {{ job_name }} -n {{ k8s_namespace }}
   ```

2. Check for recent jobs:
   ```bash
   kubectl get jobs -n {{ k8s_namespace }} -l app={{ job_name }}
   ```

3. Check pod logs:
   ```bash
   kubectl logs -l app={{ job_name }} -n {{ k8s_namespace }} --tail=100
   ```

4. Check for errors:
   ```bash
   kubectl get events -n {{ k8s_namespace }} --sort-by='.lastTimestamp'
   ```

5. Verify image:
   ```bash
   kubectl describe cronjob {{ job_name }} -n {{ k8s_namespace }} | grep Image
   ```
{% endif %}

## Schedule Format

{% if schedule_type in ['cron', 'kubernetes'] %}
### Cron Format

```
* * * * *
│ │ │ │ │
│ │ │ │ └─── Day of week (0-7, Sun-Sat)
│ │ │ └───── Month (1-12)
│ │ └─────── Day of month (1-31)
│ └───────── Hour (0-23)
└─────────── Minute (0-59)
```

**Examples:**
- `0 2 * * *` - Daily at 2am
- `*/15 * * * *` - Every 15 minutes
- `0 */4 * * *` - Every 4 hours
- `0 0 * * 0` - Weekly on Sunday at midnight
-