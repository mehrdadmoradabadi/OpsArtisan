"""Environment-specific configuration management."""

import json
from pathlib import Path
from typing import Dict, Any, List, Optional
import click


class EnvironmentManager:
    """Manages environment-specific configurations."""

    COMMON_ENVIRONMENTS = ['dev', 'development', 'staging', 'prod', 'production', 'test']

    def __init__(self, base_dir: Path):
        self.base_dir = base_dir
        self.env_dir = base_dir / 'environments'

    def create_environment(
            self,
            env_name: str,
            base_config: Dict[str, Any],
            overrides: Dict[str, Any]
    ) -> Path:
        """
        Create an environment-specific configuration.

        Args:
            env_name: Environment name (dev, staging, prod, etc.)
            base_config: Base configuration values
            overrides: Environment-specific overrides

        Returns:
            Path to created environment config
        """
        self.env_dir.mkdir(parents=True, exist_ok=True)

        # Merge base config with overrides
        env_config = self._deep_merge(base_config.copy(), overrides)

        # Save environment config
        env_file = self.env_dir / f'{env_name}.json'
        with open(env_file, 'w') as f:
            json.dump(env_config, f, indent=2)

        click.echo(f"Created environment config: {env_file}")
        return env_file

    def load_environment(self, env_name: str) -> Optional[Dict[str, Any]]:
        """Load an environment configuration."""
        env_file = self.env_dir / f'{env_name}.json'

        if not env_file.exists():
            return None

        with open(env_file) as f:
            return json.load(f)

    def list_environments(self) -> List[str]:
        """List all available environments."""
        if not self.env_dir.exists():
            return []

        envs = []
        for file in self.env_dir.glob('*.json'):
            envs.append(file.stem)

        return sorted(envs)

    def generate_variants(
            self,
            template: Dict[str, Any],
            base_answers: Dict[str, Any],
            environments: List[str]
    ) -> Dict[str, Dict[str, Any]]:
        """
        Generate configuration variants for multiple environments.

        Args:
            template: Template definition
            base_answers: Base configuration answers
            environments: List of environment names

        Returns:
            Dict mapping environment name to configuration
        """
        variants = {}

        for env_name in environments:
            # Load environment-specific overrides if they exist
            env_overrides = self.load_environment(env_name) or {}

            # Apply environment-specific defaults from template
            env_defaults = template.get('environment_defaults', {}).get(env_name, {})

            # Merge: base_answers -> env_defaults -> env_overrides
            variant_config = self._deep_merge(
                base_answers.copy(),
                self._deep_merge(env_defaults, env_overrides)
            )

            # Add environment marker
            variant_config['environment'] = env_name

            variants[env_name] = variant_config

        return variants

    def create_env_file(
            self,
            env_name: str,
            config: Dict[str, Any],
            output_path: Optional[Path] = None
    ):
        """
        Create a .env file for an environment.

        Args:
            env_name: Environment name
            config: Configuration dictionary
            output_path: Optional custom output path
        """
        if output_path is None:
            output_path = self.base_dir / f'.env.{env_name}'

        with open(output_path, 'w') as f:
            f.write(f"# Environment: {env_name}\n")
            f.write(f"# Generated by OpsArtisan\n\n")

            for key, value in sorted(config.items()):
                # Convert to uppercase for env vars
                env_key = key.upper()

                # Handle different value types
                if isinstance(value, bool):
                    env_value = 'true' if value else 'false'
                elif isinstance(value, (list, dict)):
                    env_value = json.dumps(value)
                else:
                    env_value = str(value)

                # Quote if contains spaces
                if ' ' in env_value:
                    env_value = f'"{env_value}"'

                f.write(f'{env_key}={env_value}\n')

        click.echo(f"Created .env file: {output_path}")

    @staticmethod
    def _deep_merge(base: Dict[str, Any], override: Dict[str, Any]) -> Dict[str, Any]:
        """Deep merge two dictionaries."""
        result = base.copy()

        for key, value in override.items():
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = EnvironmentManager._deep_merge(result[key], value)
            else:
                result[key] = value

        return result

    def create_comparison_report(
            self,
            variants: Dict[str, Dict[str, Any]]
    ) -> str:
        """
        Create a comparison report of different environment configurations.
        """
        if not variants:
            return "No variants to compare"

        # Get all keys from all variants
        all_keys = set()
        for config in variants.values():
            all_keys.update(config.keys())

        # Build comparison table
        lines = ["# Environment Configuration Comparison\n"]
        lines.append(f"{'Key':<30} | " + " | ".join(f"{env:<15}" for env in variants.keys()))
        lines.append("-" * (30 + 3 + len(variants) * 18))

        for key in sorted(all_keys):
            values = []
            for env_name in variants.keys():
                value = variants[env_name].get(key, 'N/A')
                if isinstance(value, (list, dict)):
                    value = json.dumps(value)[:12] + "..."
                else:
                    value = str(value)[:15]
                values.append(value)

            line = f"{key:<30} | " + " | ".join(f"{v:<15}" for v in values)
            lines.append(line)

        return "\n".join(lines)

    def validate_environment_config(
            self,
            env_name: str,
            config: Dict[str, Any],
            required_keys: List[str]
    ) -> List[str]:
        """
        Validate an environment configuration.

        Returns:
            List of validation errors
        """
        errors = []

        # Check required keys
        for key in required_keys:
            if key not in config:
                errors.append(f"Missing required key '{key}' in {env_name} environment")

        # Environment-specific validation rules
        if env_name in ['prod', 'production']:
            # Production should have stricter settings
            if config.get('debug', False):
                errors.append("Debug mode should be disabled in production")

            if config.get('ssl_enabled', True) is False:
                errors.append("SSL should be enabled in production")

            if not config.get('monitoring_enabled'):
                errors.append("Monitoring should be enabled in production")

        if env_name in ['dev', 'development']:
            # Development warnings
            if not config.get('debug', False):
                errors.append("Consider enabling debug mode in development")

        return errors